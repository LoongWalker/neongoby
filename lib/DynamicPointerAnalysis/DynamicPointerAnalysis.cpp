// Author: Jingyue

#include <cstdio>
#include <set>
using namespace std;

#include "llvm/Pass.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/raw_ostream.h"
using namespace llvm;

#include "common/PointerAnalysis.h"
using namespace rcs;

#include "dyn-aa/LogRecord.h"
#include "dyn-aa/IntervalTree.h"
using namespace dyn_aa;

namespace dyn_aa {
struct DynamicPointerAnalysis: public ModulePass, public PointerAnalysis {
  static char ID;

  DynamicPointerAnalysis(): ModulePass(ID) {}
  virtual bool runOnModule(Module &M);
  virtual void getAnalysisUsage(AnalysisUsage &AU) const;

  virtual void getAllPointers(ValueList &Pointers);
  virtual bool getPointees(const Value *Pointer, ValueList &Pointees);

  virtual void *getAdjustedAnalysisPointer(AnalysisID PI);

 private:
  void processAddrTakenDecl(const AddrTakenDeclLogRecord &Record);
  void processTopLevelPointTo(const TopLevelPointToLogRecord &Record);
  void processAddrTakenPointTo(const AddrTakenPointToLogRecord &Record);
  // Returns the value ID of <Addr>'s allocator. 
  // Possible allocators include malloc function calls, AllocaInsts, and
  // global variables. 
  Value *lookupAddress(void *Addr) const;

  // Stores all addr-taken declarations. 
  IntervalTree AddrTakenDecls;
  // Use DenseSet instead of vector, because they are usually lots of 
  // duplicated edges. 
  DenseMap<const Value *, ValueSet> PointTos;
};
}

static RegisterPass<DynamicPointerAnalysis> X("dyn-pa", 
                                              "Build the point-to graph from "
                                              "the point-to log",
                                              false,
                                              true);
static RegisterAnalysisGroup<PointerAnalysis> Y(X);

static cl::opt<string> LogFileName("log-file",
                                   cl::desc("Point-to log file generated by "
                                            "running the instrumented program"),
                                   cl::init(""));

char DynamicPointerAnalysis::ID = 0;

bool DynamicPointerAnalysis::runOnModule(Module &M) {
  LogRecordType RecordType;
  int numRecords = 0;
  int numAddrTakenDecls = 0;
  int numAddrTakenPointTos = 0;
  int numTopLevelPointTos = 0;

  FILE *LogFile = fopen(LogFileName.c_str(), "rb");
  while (fread(&RecordType, sizeof RecordType, 1, LogFile) == 1) {
    if (numRecords % 1000000 == 0)
      errs() << "Processed " << numRecords << " records\n";
    ++numRecords;
    switch (RecordType) {
      case AddrTakenDecl:
        {
          ++numAddrTakenDecls;
          AddrTakenDeclLogRecord Record;
          assert(fread(&Record, sizeof Record, 1, LogFile) == 1);
          processAddrTakenDecl(Record);
        }
        break;
      case TopLevelPointTo:
        {
          ++numTopLevelPointTos;
          TopLevelPointToLogRecord Record;
          assert(fread(&Record, sizeof Record, 1, LogFile) == 1);
          processTopLevelPointTo(Record);
        }
        break;
      case AddrTakenPointTo:
        {
          ++numAddrTakenPointTos;
          AddrTakenPointToLogRecord Record;
          assert(fread(&Record, sizeof Record, 1, LogFile) == 1);
          processAddrTakenPointTo(Record);
        }
        break;
      default:
        fprintf(stderr, "RecordType = %d\n", RecordType);
        assert(false && "Unknown record type");
    }
  }

  errs() << "Processed " << numRecords << " records\n";
  errs() << "# of addr-taken decls = " << numAddrTakenDecls << "\n";
  errs() << "# of addr-taken point-tos = " << numAddrTakenPointTos << "\n";
  errs() << "# of top-level point-tos = " << numTopLevelPointTos << "\n";

  return false;
}

void DynamicPointerAnalysis::getAnalysisUsage(AnalysisUsage &AU) const {
  AU.setPreservesAll();
  AU.addRequired<IDAssigner>();
}

void DynamicPointerAnalysis::processAddrTakenDecl(
    const AddrTakenDeclLogRecord &Record) {
  IDAssigner &IDA = getAnalysis<IDAssigner>();

  Value *Allocator = NULL;
  if (Record.AllocatedBy != IDAssigner::INVALID_ID)
    Allocator = IDA.getValue(Record.AllocatedBy);
  // Allocator may be NULL. 
  // In that case, the memory block is allocated by an external instruction.
  // e.g. main arguments. 

  unsigned long Start = (unsigned long)Record.Address;
  Interval I(Start, Start + Record.Bound);
  pair<IntervalTree::iterator, IntervalTree::iterator> ER =
      AddrTakenDecls.equal_range(I);
  AddrTakenDecls.erase(ER.first, ER.second);
  AddrTakenDecls.insert(make_pair(I, Allocator));
}

void DynamicPointerAnalysis::processTopLevelPointTo(
    const TopLevelPointToLogRecord &Record) {
  IDAssigner &IDA = getAnalysis<IDAssigner>();

  Value *Pointer = IDA.getValue(Record.PointerValueID);
  Value *Pointee = lookupAddress(Record.PointeeAddress);
  assert(Pointer);
  if (Pointee)
    PointTos[Pointer].insert(Pointee);
}

void DynamicPointerAnalysis::processAddrTakenPointTo(
    const AddrTakenPointToLogRecord &Record) {
  Value *Pointer = lookupAddress(Record.PointerAddress);
  Value *Pointee = lookupAddress(Record.PointeeAddress);
  assert(Pointer);
  if (Pointee)
    PointTos[Pointer].insert(Pointee);
}

Value *DynamicPointerAnalysis::lookupAddress(void *Addr) const {
  Interval I((unsigned long)Addr, (unsigned long)Addr + 1);
  IntervalTree::const_iterator Pos = AddrTakenDecls.find(I);
  if (Pos == AddrTakenDecls.end())
    return NULL;
  return Pos->second;
}

bool DynamicPointerAnalysis::getPointees(const Value *Pointer,
                                         ValueList &Pointees) {
  Pointees.clear();
  DenseMap<const Value *, ValueSet>::iterator I = PointTos.find(Pointer);
  if (I == PointTos.end())
    return false;

  Pointees.insert(Pointees.end(), I->second.begin(), I->second.end());
  return true;
}

void DynamicPointerAnalysis::getAllPointers(ValueList &Pointers) {
  for (DenseMap<const Value *, ValueSet>::iterator I = PointTos.begin();
       I != PointTos.end(); ++I) {
    Pointers.push_back(const_cast<Value *>(I->first));
  }
}

void *DynamicPointerAnalysis::getAdjustedAnalysisPointer(AnalysisID PI) {
  if (PI == &PointerAnalysis::ID)
    return (PointerAnalysis *)this;
  return this;
}
