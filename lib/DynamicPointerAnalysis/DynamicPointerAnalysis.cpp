// Author: Jingyue

#define DEBUG_TYPE "dyn-pa"

#include <cstdio>
using namespace std;

#include "llvm/Pass.h"
#include "llvm/Support/CommandLine.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/ADT/Statistic.h"
using namespace llvm;

#include "dyn-aa/DynamicPointerAnalysis.h"
using namespace dyn_aa;

static RegisterPass<DynamicPointerAnalysis> X("dyn-pa",
                                              "Build the point-to graph "
                                              "from the point-to log",
                                              false, // Is CFG Only?
                                              true); // Is Analysis?
static RegisterAnalysisGroup<PointerAnalysis> Y(X);

static cl::opt<string> LogFileName("log-file",
                                   cl::desc("Point-to log file generated by "
                                            "running the instrumented program"),
                                   cl::init(""));

STATISTIC(NumAddrTakenDecls, "Number of addr-taken declaration records");
STATISTIC(NumAddrTakenPointTos, "Number of addr-taken point-to records");
STATISTIC(NumTopLevelPointTos, "Number of top-level point-tos records");
STATISTIC(NumRecords, "Number of all records");

char DynamicPointerAnalysis::ID = 0;

bool DynamicPointerAnalysis::runOnModule(Module &M) {
  assert(LogFileName != "");

  FILE *LogFile = fopen(LogFileName.c_str(), "rb");

  LogRecordType RecordType;
  while (fread(&RecordType, sizeof RecordType, 1, LogFile) == 1) {
    if (NumRecords % 1000000 == 0)
      errs() << "Processed " << NumRecords << " records\n";
    ++NumRecords;
    switch (RecordType) {
      case AddrTakenDecl:
        {
          ++NumAddrTakenDecls;
          AddrTakenDeclLogRecord Record;
          assert(fread(&Record, sizeof Record, 1, LogFile) == 1);
          processAddrTakenDecl(Record);
        }
        break;
      case TopLevelPointTo:
        {
          ++NumTopLevelPointTos;
          TopLevelPointToLogRecord Record;
          assert(fread(&Record, sizeof Record, 1, LogFile) == 1);
          processTopLevelPointTo(Record);
        }
        break;
      case AddrTakenPointTo:
        {
          ++NumAddrTakenPointTos;
          AddrTakenPointToLogRecord Record;
          assert(fread(&Record, sizeof Record, 1, LogFile) == 1);
          processAddrTakenPointTo(Record);
        }
        break;
      default:
        fprintf(stderr, "RecordType = %d\n", RecordType);
        assert(false && "Unknown record type");
    }
  }

  fclose(LogFile);

  errs() << "Processed " << NumRecords << " records\n";

  return false;
}

void DynamicPointerAnalysis::getAnalysisUsage(AnalysisUsage &AU) const {
  AU.setPreservesAll();
  AU.addRequired<IDAssigner>();
}

void DynamicPointerAnalysis::processAddrTakenDecl(
    const AddrTakenDeclLogRecord &Record) {
  IDAssigner &IDA = getAnalysis<IDAssigner>();

  Value *Allocator = NULL;
  if (Record.AllocatedBy != IDAssigner::INVALID_ID)
    Allocator = IDA.getValue(Record.AllocatedBy);
  // Allocator may be NULL.
  // In that case, the memory block is allocated by an external instruction.
  // e.g. main arguments.

  unsigned long Start = (unsigned long)Record.Address;
  Interval I(Start, Start + Record.Bound);
  pair<IntervalTree::iterator, IntervalTree::iterator> ER =
      AddrTakenDecls.equal_range(I);
  AddrTakenDecls.erase(ER.first, ER.second);
  AddrTakenDecls.insert(make_pair(I, Allocator));
}

void DynamicPointerAnalysis::processTopLevelPointTo(
    const TopLevelPointToLogRecord &Record) {
  IDAssigner &IDA = getAnalysis<IDAssigner>();

  Value *Pointer = IDA.getValue(Record.PointerValueID);
  Value *Pointee = lookupAddress(Record.PointeeAddress);
  assert(Pointer);
  if (Pointee) {
    PointTos[Pointer].insert(Pointee);
  }
}

void DynamicPointerAnalysis::processAddrTakenPointTo(
    const AddrTakenPointToLogRecord &Record) {
  // We needn't do anything on AddrTakenPointToLogRecords, because currently
  // pointers are all virtual registers (top-level variables).
}

Value *DynamicPointerAnalysis::lookupAddress(void *Addr) const {
  Interval I((unsigned long)Addr, (unsigned long)Addr + 1);
  IntervalTree::const_iterator Pos = AddrTakenDecls.find(I);
  if (Pos == AddrTakenDecls.end())
    return NULL;
  return Pos->second;
}

bool DynamicPointerAnalysis::getPointees(const Value *Pointer,
                                         ValueList &Pointees) {
  Pointees.clear();
  DenseMap<const Value *, ValueSet>::iterator I = PointTos.find(Pointer);
  if (I == PointTos.end())
    return false;

  Pointees.insert(Pointees.end(), I->second.begin(), I->second.end());
  return true;
}

void DynamicPointerAnalysis::getAllPointers(ValueList &Pointers) {
  for (DenseMap<const Value *, ValueSet>::iterator I = PointTos.begin();
       I != PointTos.end(); ++I) {
    Pointers.push_back(const_cast<Value *>(I->first));
  }
}

void *DynamicPointerAnalysis::getAdjustedAnalysisPointer(AnalysisID PI) {
  if (PI == &PointerAnalysis::ID)
    return (PointerAnalysis *)this;
  return this;
}
